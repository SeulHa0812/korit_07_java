# 향상된 for문(Enhanced For Loop)
### 일반 for 문과의 차이점 :
    일반 for 문의 경우 index 넘버(주소지)를 명확하게 알고 있어야하지만
    일일이 element의 숫자를 세는 것이 번거롭기 때문에 arr01.length와 같은 방식으로 
    일종의 field 참조를 통해 int 값을 추출하여 대입해야만 했음.

    그런데 for (int i = 0 ; ...) 부분에서 int i는
    for문 내부에서 선언되고, 내부에서만 사용 가능.

    이를 응용하여 배열 내의 element에 for문 내부에서만 사용하는 변수에 대입하는
    방식으로 index 넘버(주소지)의 사용없이 적용할 수 있는 for 반복문이 있는데.
    이를 향상된 for 문이라고 함
### 제약 :
    읽기만 되고, 쓰기가 안됨. 
    (1부터 100까지 추출하는건 되는데 집어넣는건 제한적으로 된다 등)
### 형식 :
    for(자료형 변수명 : 반복가능객체(배열)) {
        반복실행문
    }
```java
 public static void main(String[] args) {
        int[] nums = new int[200]; // 빈 배열 == 다 0으로 되어있는 200칸 짜리
        //1~200 대입
        // 일반 for 문 형태로 1 2 3 4 5 6 /// 200 출력
        for (int i = 0 ; i < nums.length ; i++) {
            nums[i] = (i+1);
            System.out.print(nums[i] + " ");
        }

        //향상된 for 문으로 출력
        for (int number : nums) { // int[] x
            System.out.print(number + " ");
        }
        // #2
        String[] persons = { "김일", "김이", "김삼", "김사", "김오"};
        for (int i = 0 ; i < persons.length ; i++) {
            System.out.println((i+1) + " 번 : " + persons[i]);
        }

        System.out.println();
        int count = 0;
        for (String person : persons) {
            System.out.println(++count + "번 : " + person);
        }
    }
```
 
### cord convention 관련

```java
import java.util.Scanner;

public class PersonMain {
    public static void main(String[] args) {
        // 사용할 외부 및 내부 클래스 목록들 전부 import
        Scanner scanner = new Scanner(System.in);
        Array08 array08 = new Array08();
        //사용하는 변수 목록들 전부 선언
        int randomNum;
        double[] scores = new double[25];
        String[] students = new String[25];
        //...
        //막 내부 로직들 엄청나게 써놓고 있다고 가정하다가 저 밑에서ㅓ
        // students 튀어나왔다고 가정
        if (randomNum < 0)
        {
            //이런 방식으로 실행문을 써야 합니다. 라는 식으로 회사에서 정하는 경우가 있음
        }
    }
}
```
### 배열의 출력
    이때까지 배열 출력이 아니라 배열 내부의 element 출력
    sout(arr01); 과 같은 출력문을 작성했을 때
    주소값만 나온다는 사실을 확인할 수 있음

    근데 element의 값을 조정하거나, 더하거나와 같은 추가적인 가공을 하기 위해서
    for 반복문을 사용해왔는데, 굳이 변형이 없고 배열 자체를 확인하고 싶을 때마다
    main에 반복문 작성하든지 method를 정의하든지 하는 일은 번거로운 일이 됨

    해결 방법:
    Array.toString(배열명)
    Arrays 클래스를 사용하고 '정적' 메서드인 .toString(배열명)을 사용하면
    배열 전체를 출력할 수 잇음

    여기서 우리는 클래스명.메서드명()이라는 점에 주목할 필요 있음
    scanner.newtLine()과는 다름
    그리고 toString()이라는 메서드도 곧 사용하게 됨

    여기서 중요한 점은 동일한 메서드 명이라고 하더라도 어떤 클래스에 종속되어있는가에 따라
    다른 결과값을 지닐 수 있다는 점
```java
public static void main(String[] args) {
    //int[] 배열에 1, 2, 3, 4, 5...10까지 대입
    int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    //배열의 전체 출력 예시
    System.out.println(Arrays.toString(numbers));

    Method01.call1(); //타 클래스에서 호출하기위해서는 클래스이름 명시해야함
    System.out.println(Method01.call3());
}

```
### 배열의 오름 차순 & 내림 차순
```java
public static void main(String[] args) {
    Integer[] nums = {3, 6, 7, 1, 9, 2, 10, 5, 4, 8};
    System.out.println("정렬 전 배열 : " + Arrays.toString(nums));
    // 오름 차순 정렬
    Arrays.sort(nums); // 얘의 결과값이 void니까 원본 배열의 정렬을 함
    System.out.println("오름 차순 정렬 후 배열 : " + Arrays.toString(nums));
    // 내림 차순
    Arrays.sort(nums, Comparator.reverseOrder());
    System.out.println("내림 차순 정렬 후 배열 : " + Arrays.toString(nums));
}
```
오름 차순 = argument 1개  
내림 차순 - argument 2개  
--> overloading 이루어짐  
--> Comparator.reverseOrder()의 결과값/return 값이 sort() 메서드의  
두 번째 argument로 사용되었다는 점에서 함수형 프로그래밍의 일종  
(함수형 프로그래밍: 데이터를 변경하지 않고 순수 함수들을 조합하여 결과를 만들어내는 방식)  

내림 차순의 Comparator.reverseOrder()를 쓰려면  
기본 자료형(원시 자료형/ primitive type) int[] 배열을 사용할 수 없어서  
Integer[] 배열을 사용 (char -> String 처럼 int -> Integer)

### 다차원 배열 (Multi-Dimensional Array)
    2차원 배열
    형식 :
    int[][] arr01 = mew int[크기][크기]; - 선언방식 #1
    int[][] arr02 = new int[크기][]; - 선언방식 #2
    int[][] arr03 = { { 1, 2 }, { 3, 4 }, { 5, 6 } } - 선언방식 #3 및 초기화
       행 열

    2차원 배열 선언 시, 열의 크기는 지정하지 않아도 되지만, 행의 크기는 항상 지정해야 함.
        -> 2번 방식에 해당함.
        (0번지, 1번지)
         1열 2열(colum)
          ↆ  ↆ
        { 1, 2 }, → 1 행 (row) 가로줄을 '행'
        { 3, 4 }, → 2 행
        { 5, 6 }  → 3 행 (0번지, 1번지)

```java
    public static void main(String[] args) {
        int[][] arr03 = {{1, 2}, {3, 4}, {5, 6}};
        // 2차 배열의 element 추출 -> 중첩 for 문 사용
        for (int i = 0; i < arr03.length; i++) {
            //반복문 추가 작성
            for (int j = 0; j < arr03[i].length; j++) {
                System.out.println(arr03[i][j]);
            }
        }

        // 향상된 for 문으로 2차 배열 내부의 element
        for (int[] firstArr : arr03) {
            for (int element : firstArr) {
                System.out.print(element + " ");
            }
//            System.out.println();
        }
    }
```
++ Array14 이해하기

# 상속
- 객체지향프로그래밍의 핵심 개념 중 하나로, 기존 클래스(부모(슈퍼) 클래스)의 
field와 method를 재사용하여 새로운 클래스(자식(서브) 클래스)를 만드는 것 의미

## 상속의 필요성
- 상속을 통해 공통적인 기능을 부모 클래스에 정의하고, 이를 '여러' 자식 클래스가 재사용 가능
  - 동물(animal)클래스가 있고, 이를 상속 받는 Dog/Cat 클래스가 있다고 가정했을 때
동물의 공통적인 field(이름/ 나이 등)와 행위(걷기/먹기 등)을 
부모 클래스에 정의, 개와 고양이는 각각 고유한 특성(짖기/ 우다다다)을 추가할 수 있음

- 이상의 과정을 거쳤을 때 얻을 수 있는 이점 : Dog에 이름/ 나이/ 걷기/ 먹기/ 짖기를 정의하고
또 Cat 에다가 이름/ 나이/ 걷기/ 먹기/ 우다다다를 정의하는 등의 공통된 부분을
정의하는 일 없이 특정 필드 및 메서드만 정의하면 됨. -> 중복된 코드 줄일 수 있음

## 상속의 특징
1. 단일 상속
   - 자바는 단일 상속만 지원함. 하나의 클래스는 한 번에 하나이 부모 클래스만 상속 받을 수 있어
   상속 구조가 간단하고 명확함.
2. super 키워드
   - 클래스의 생성자 및 setter에서 학습한 this와 유사한 개념으로
   부모 클래스의 필드에 접근하거나 부모 클래스의 생성자를 호출할 때 사용함(두 가지 사용법이 있음)
3. _method override_
   - 자식 클래스에서 부모 클래스의 기본 동작을 _재정의_ 할 수 있음. 이를 통해 자식 클래스는
        부모 클래스의 기본 동장을 자신만의 방식으로 변경 가능
   - 예시
     -  Animal 클래스의 걷기를 Dog가 상속 받고, 네 발걷기로 _재정의_, Human 클래스가 걷기를
        상속 받고 두 발로 걷기로 _재정의_가 가능함.
4. final 키워드 - 클래스에 final이 붙으면 상속 불가
   - method에 final이 붙으면 메서드 오버라이딩 불가능

## 장점
1. 코드 재사용성 - 동일한 코드를 반복적으로 작성할 필요 x
2. 유지 보수의 용이성
   - 부모 클래스의 변경 사항이 자식 클래스에 자동으로 반영되기 때문에
     위계 파악 후 수정하면 됨.
3. 객체 간 관계 표현 - IS-A 관계를 명확히 나타냄.
   - IS-A  
   '개'는 '동물'의 일종이다. 와 같은 예시로, IS-A는 is a kind of 의 축약어  
   그래서 우리가 미리 만들어둔 Animal / Tiger / Human의 클래스를 예로 들었을 때  
   Human / Tiger는 Animal 클래스의 자식(서브) 클래스다.

