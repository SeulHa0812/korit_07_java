# 제네릭(Generic)
## 개념 및 정의
클래스나 메서드가 다룰 데이터 타입을 미리 명시하여 재사용성과 유연성을 높이는 기술

### 타입 매개변수(Type Parameter)
- 클래스나 메서드에서 사용할 실제 타입을 '대신하여 사용하는 매개변수'
- 일반적으로 알파벳 대문자 하나로 표기함.
  1. T(type) : 일반적으로 클래스 타입을 나타낼 때 사용
  2. E(element) : 컬렉션의 요소를 나타낼 때 사용
  3. K(key) : Map의 Key를 나타낼 때 사용
  4. V(value) : Map의 Value 또는 제네릭 타입의 리턴 값으로 사용
### 재사용성
- 제네릭을 사용하면 다양한 자료형에 대해 하나의 클래스나 메서드를 정의할 수 있어
 코드의 재사요성을 높이고 중복을 줄임.

- 예를 들어 method overloading 개념이 있을 경우, Person 객체를 참조하여
  bmi를 계산한다고 가정
```java
import lombok.*;

@Builder
@Data
public class Person {
    private String name;
    private double height;
    private double weight;
}

public void calcBmi(Person person) {
    String name = person.getName(); 
    double height = person.getHeight() * 0.01;
    double weight = person.getWeight();
    double bmi = weight /(height*height);
    String result = "";
    if (bmi < 18.5) {
        result = "저체중";
    } else if (bmi < 23) {
        result = "비만 전 단계";
    } else if (bmi < 25) {
        result = "1단계 비만";
    } else if (bmi < 30) {
        result =  "2단계 비만";
    } else if (bmi < 35) {
        result = "3단계 고도비만";
    } else {
        System.out.println("잘못된 입력값입니다.");
    }
    System.out.println(name + " 님의 BMI 지수는 " + bmi + "로 " + result + "입니다.");

}
```
이상과 같이 쓸 수 있음. 그렇다면, 만약에 Student 클래스가 Person 클래스를 상속 받았다고 가정할 때, Student 클래스 용으로 또 method overloading을 해야하는가와 같은 문제가 있음. 
그리고 Student의 상속을 받는 MiddleSchoolStudent 라든지 HighSchoolStudent가 있으면 더 골치가 아파짐.
* 참고 : 사실은 upcasting이 이루어지기 때문에 별 문제 없음.

### 타입 안정성(Type Safety)
- 컴파일 시점에 타입 체크를 할 수 있어 프로그램의 안정성을 높이고, 명시적인 형변환을 줄임.

# Java 제네릭 와일드카드(Generic Wildcard)

## 제네릭
- 클래스, 인터페이스, 메서드에 사용되는 자료형을 매개변수화 할 수 있도록 하는 문법으로
다양한 타입에서 재사용이 가능.
```java
public class Box<T> {
    //field
    private T value;
    public void setValue(T value) {
        this.value = value;
    }
    public T getValue() {
        return value;
    }
}
```
과 같은 방식으로 작성했을 때 value의 자료형을 고정시키지 않고 사용 가능.
value에 String / Integer / Double / Product / Item ...etc 등으로 사용 가능.
즉 Java 자체의 자료형(class) 뿐만 아니라 개발자가 정의한 것도 집어넣을 수 있다는 점에서 재사용성이 높다고 할 수 있음.

## 와일드카드
- 이상의 제네릭 타입을 사용할 때 구체적인 타입을 명시하지 않고 범용적으로 처리하고 싶을 때 사용함. 
- '?' 기호 사용.

```java
import java.util.ArrayList;

public static void main(String[] args) {
    List<?> exampleList = new ArrayList<String>();
}
```
'<?>'은 어떤 타입이든 가능하다는 의미

### 종류
1. 모든 타입 허용
    - 읽기 전용. 어떤 타입이든지 받아야만 할 때
2. T 또는 T의 서브 타입(자식 클래스)
    - 읽기 전용. 제한된 타입에서 읽을 때
3. T 또는 T의 슈퍼 타입(부모 클래스)
    - 쓰기 전용. 제한된 타입으로 넣을 때

# Collection
- 여러 객체를 모아놓은 것들을 의미함 -> 배열과는 좀 차이가 있음
- 다만 Java에서의 List는 Python에서의 List와도 차이가 있음

## 종류
1. List : 순서가 있는 데이터의 집합으로, 중복된 요소를 허락함
    - ArrayList : 배열 기반의 리스트, 요소(element) 접근 속도가 빠름.
    - LinkedList : 연결 리스트, 삽입 / 삭제 속도가 빠름.
2. Set : 중복을 허용하지 않는 (List와의 차이 #1)데이터들의 집합(중1 때 배우는 그 집합)
    - HashSet : 해시 테이블 기반의 집합, element의 순서를 보장하지 않음(List와의 차이 #2)
    - TreeSet : 이진(binary) 검색 트리 기반의 집합, 요소가 정렬된 상태로 유지됨.
3. Map : Key / Value의 쌍으로 이루어진 데이터들의 집합.
    - HashMap : 해시 테이블 기반의 맵, 키의 순서를 보장 x
    - TreeMap : 이진 검색 트리 기반의 맵, 키가 정렬된 상태로 유지

* Java 상에서의 키(Key)-값(Value) 쌍을 지칭하는 용어 : Entry
* Js 상에서의 객체의 키-값 쌍을 지칭하는 용어 : Property(속성)
* 근데 문제는 Python 에서의 한국어로 속성을 지칭하는 영문 용어 : Attributes - Java 상에서의 field

### List
1. 선언 방식
```java
List<String> strList = new ArrayList<>();
```
2. 값을 대입하는 방법 (메서드를 통해 집어넣어야함)
객체명.add();
```java
strList.add("java");
strList.add("python");
strList.add("javascript");
strList.add("C#");
strList.add("C++");
// 순서가 보장된다고 했기 때문에 집어넣은 순서대로 값이 들어감
```
3. 츨력 방식
```java
 // List - toString() overriding 되어있다고 볼 수 있음
System.out.println(strList); //객체명을 넣었을때 출력이 되니까
```
4. 특정 element 검색 (contains() 메서드 사용)
리스트명.contains(목적어)
```java
String searchElem1 = "python";
boolean contains1 = strList.contains(searchElem1);
System.out.println(searchElem1 + " 포함 여부 : " + contains1); //result : true
String searchElem2 = "py";
boolean contains2 = strList.contains(searchElem2);
System.out.println(searchElem2 + " 포함 여부 : " + contains2); //result : false
```
5. 특정 element 삭제
리스트명.remove(특정 element);
```java
String removeElem1 = "javascript";
boolean isRemoved = strList.remove(removeElem1);
System.out.println(removeElem1 + " 삭제 여부 : " + isRemoved);
```
6.List 정렬
```java
Collections.sort(strList); 
// 배열 정렬할 때와 동일. 원본 List의 결과값을 바꿈
System.out.println(strList);
```
7.List 역순 정렬
```java
Collections.sort(strList, Comparator.reverseOrder());
System.out.println(strList);
```
8. 전체 element 출력 방법
```java
//일반 for 문
for ( int i = 0 ; i < strList.size() ; i++ ) {
    System.out.println(strList.get(i));
    }
//향상된 for 문
for ( String elem : strList ) {
    System.out.println(elem + " ");
    }
```

### Set
1. 선언 방식
```java
Set<String> strSet = new HashSet<>(); 
//빨간 줄 뜨면 alt + enter
```
2. 값을 대입하는 방법 (메서드를 통해 집어넣어야함)
   객체명.add(); == List와 동일
3. 출력 방식
```java
 System.out.println(strSet);
```

### List to Set for 중복 제거
리스트명.addAll(세트명);
strSet.addAll(strList); //SVO

### Set to List for element 추출하여 데이터 조작
List<String> modifiedStrList = new ArrayList<>();
modifiedStrList.addAll(strSet); 
//중복 제거된 set 요소들을 새로운 List에 대입하는 과정