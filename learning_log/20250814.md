### Map (collections)
1. 선언 방식
Map<key-datatype, value-datatype> map(name) = new HashMap<>();
```java
Map<String, String> strMap1 = new HashMap<>();
```
2. 값을 대입하는 방법
.put(키, 값);
```java
strMap1.put("kor2025001", "김일");
```
3. 출력 방식
***입력한 순서대로 출력 x
```java
System.out.println(strMap1);
```
4. key or value 변경
#1. key 하나당 value는 하나. 즉 키가 같다면 value는 가장 최근 걸로 덮어쓰기 됨.
```java
strMap1.put("kor2025005", "KimFive");
// result : {kor2025005=KimFive}
```
#2. .replace();
```java
koreanScores.replace("김오", 789.2);
System.out.println(koreanScores);
/*
            두 가지 방법이 있는 이유는 .put() 경우에는
            없는 key 라면 key를 새로 생성해서 value를 초기화하겠지만
            있는 key 라면 value에 재대입을 하게 됨.
            
            반면 .replace()는 없는 key 라면 value 값의 갱신 x
            있는 key 라면 재대입이 일어난다는 차이가 있음
         */
```

5. 조회 방법
.get("키값");
***index 조회 x -> 순서 보장 x 때문
*** 값 조작 가능
```java
System.out.println(strMap1.get("kor2025001") + " 님");
```
6. 특정 key or value 존재 여부
containsKey(); -> boolean(return type)
containsValue(); -> boolean(return type)
```java
 boolean searchKeyFlag1 = strMap1.containsKey("김육");
System.out.println("김육 학생 존재 여부 : " + searchKeyFlag1);
        
boolean searchValueFlag1 = strMap1.containsValue("김삼");
System.out.println("김삼 존재 여부 : " + searchValueFlag1);
```
7. Map inside Set
```java
Set<Map.Entry<String, String>> entrySet1 = new HashSet<>(); // Set에 Map 통째로 들어감
Set<Map.Entry<String, String>> entrySet2 = strMap1.entrySet();
// strMap1의 key-value 쌍을 Set로 바꾸는 메서드인 .entrySet()의 호출 결과를 entrySet2라는 변수에 담음
System.out.println(strMap1); // result : {}
System.out.println(entrySet2); // result : []
```
*** Map -> List 직접 변환 불가능
```java
  // Key Set 출력
        Set<String> keySet = strMap1.keySet();
        System.out.println(keySet);

        // Value Set 출력
//        Set<String> valueSet = strMap1.values(); //불가능 why?
        // * key 는 중복 불가능, but value는 중복 가능

// Instead, use 73 line
Collection<String> values = strMap1.values();
        System.out.println(values);
//Collection 자료형은 처음 씀. .sort()는 Collections 이기 때문
```

# JSON

## 정의
JSON(JavaScript Object Notation) - 본래 자바스크립트 언어로부터 파생되어 
자바스트립트 구문을 따르지만, 언어 독립형 데이터 포맷

프로그래밍 언어나 플랫폼에 독립적이기 때문에 구문 분석 및 JSON 데이터 생성을
위한 코드느 Java/Python등 다양한 언어에서 쉽게 이용 가능
```json
{
  "이름공간(key)" : "값(value)",
  "값 구분자": "각각의 값들은 ',' (콤마)로 구분되어야 합니다.",
  "이스케이프": "키나 값에서 큰따옴표를 쓰고 싶으면-특정 문자를 이스케이프하려면- \"처럼 문자 앞에 역슬래시를 붙입니다.",
  "자료형": "표현 가능한 자료형은 문자열, 숫자, 불리언, 널, 객체, 배열 6개입니다.",
  "문자열값": "나무위키, 여러분이 가꾸어 나가는 지식의 나무",
  "숫자값": 19721121,
  "불리언값": true,
  "널값": null,
  "객체값(JavaScript식)": {
    "값 1": 3.14159265358979323846264338,
    "값 2": false,
    "값 3": {
      "객체 안에": "객체를 넣는 것도 가능하지요",
      "구분자": "또한 키와 값은 ':'로 구분됩니다"
    }
  },
  "배열값": [
    "이것은 배열입니다.",
    {
      "현재값의 인덱스": 1,
      "이런 식으로": "배열 안에 여러 값을 넣을 수 있습니다."
    },
    [ "배열", "안에", "배열을", "넣는 것도", "가능하지요" ]
  ],
  "값의 개수가 적을 때는": "다음과 같이 한 줄로도 객체와 배열 표현이 가능합니다.",
  "한 줄 객체": { "김두한": "함께 폭사하자", "심영": "내가 고자라니", "의사양반": "병신을 만들어주마" ,  "조병옥": "빵빵 터뜨리고 있어요" },
  "한 줄 배열": [ "나무위키는", "누구나", "기여할", "수", "있는", "위키입니다." ], 
  "예시" : "예시입니다."
}
```
