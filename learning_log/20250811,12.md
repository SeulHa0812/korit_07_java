# Object 클래스
- 모든 클래스는 object 클래스를 상속 받는다. 그래서 interface를 implement
할 때나 다른 서브 클래스 만들어서 extends 명령어 입력했을 때 우리가 직접 만들었던
슈퍼 클래스 이외에 toString() ... 한 것들이 있음

    1. toString() : 기본적으로 모든 클래스는 Object 클래스를 상속 받아,
        클래스 이름과 해시코드(일종의 주소지 개념)를 return함.
        - 이를 Override 해서 재정의하여 클래스의 정보를 출력할 때 사용
        - ObjectTest / ObjectTestMain 클래스 작성
        - 필드를 정의하고, toString() 메서드를 override 해서 필요한 필드를 출력함
       -> Main 단계에서 특정 객체의 특정 필드를 객체의 이름만으로 출력이 가능함.(sout(객체명);으로 가능 / sout(객체명.showInfo())가 아니라.)
    
    2. equals() : 두 객체가 '논리적으로 같은지'를 비교하는 메서드(주소지의 차이가 아니라)
                    기본적으로 Object 클래스의 equals() 메서드는 두 객체의 참조 주소를 비교
            - 형식 : 객체명1.equals(객체명2) -> 객체명1과 객체명2의 참조 주소가 동일한지 확인함.
                                            3형식 문장으로 해석하면 됨. SVO.
    3. hashCode() : 객체를 정수 값(해시값)으로 변환(16진수가 아니라). 
                    해시 값은 주로 해시 기반 컬렉션에서 사용됨(추후 수업 예정).
            - equals 메서드를 재정의하게 되면 반드시 hashCode() 메서드도 재정의해야만 함.
                왜냐면 동일한 객체(equals == true)는 동일한 해시 코드를 가져야하기 때문인데,
                문제는 해시 코드가 같다고 해서 또 equals()가 true가 아닌 경우가 있음.

# Lombok
메뉴바(햄버거) -> 설정 -> 좌측에 plugins(플러그인) 선택 -> Lombok 검색 -> 설치 후
disabled/비활성화 라고 나와있으면 활성화된 상태라는 뜻

Chrome -> maven repositories로 들어가서 lombok 검색 -> 웬만하면 최신 버전
그리고 저희는 빌드 시스템이 gradle 이기 때문에(그리고 코틀린이 아니기 때문에), groovy short로 복사
그리고 annotationProcessor도 꼭 적용해야함.
```
dependencies {
    implementation 'org.projectlombok:lombok:1.18.38'
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    annotationProcessor 'org.projectlombok:lombok:1.18.38'
}
```
이상과 같이 작성되어야 함

# Lombok 주요 annotation
1. @Getter / @Setter(pascal case)
    - class level에 작성할 경우 getter/ setter method 자동 생성
    - field level에 작성할 경우 해당 필드에만 메서드 생성
    - 주의 : 객체마다 다른 값을 갖게 되는 비정형(non-static) 필드에 대해서만 적용됨
```java
@Setter
@Getter
public class Person {
    private String name;
    private int age;
}
```
2. @ToString
    - toString() method를 자동으로 생성. 근데 문제는 재정의가 안되고 Lombok 라이브러리 default 형태만 튀어나오기 때문에
        결과적으로 원하는 부분만 보여주기 위해서는 override methods(alt +  ins)를 쓰는 경우가 많을 것.

3. @EqualsAndHashCode
    - equals() / hashCode() 메서드를 자동 생성. 객체의 동일성 비교 로직을 구현할 때 사용
      - 아까 배웠던 것처럼  equals()를 재정의하면 hashCode()도 반드시 같이 재정의해야하기 때문에 애너테이션도
        세트로 묶여있음.

4. @NoArgsConstructor / @RequireArgsConstructor / @AllArgsConstructor
    - @NoArgsConstructor : argument가 없는 기본 생성자를 생성
    - @RequireArgsConstructor : final 또는 '@NonNull' 애너테이션이 붙은 필드만 필수적으로 요구하는 매개변수 생성자를 생성
    - @AllArgsConstructor : 모든 필드를 argument로 요구하는 매개변수 생성자
```java
@NoArgsConstructor
@RequiredArgsConstructor
@AllArgsConstructor
public class Person {
    @NonNull
    private String name;
    private int age;
}

public class PersonMain {
    public static void main(String[] args) {
        Person person1 = new Person(); //기본 생성자
        Person person2 = new Person("김이"); //name 요구 매개변수 생성자
        Person person3 = new Person("김삼", 20); //AllArgsConstructor
    }
}
```
5. @Data
    - @Getter / @Setter / @ToString / @EqualsAndHashCode / @RequiredArgsConstructor가 다 들어가는 종합 패키지 애너테이션 (제일 많이 쓰임)

수강생들이 클래스 만들 때 제일 먼저 하는 방식 :
```java
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Students extends Person {
    private String name;
    private int age;
    private double score;
    
}
```

6. @Builder - 추후 수업 예정

# Static

## 정의
- 클래스 수준에서 변수를 정의하거나 메서드를 선언할 때 사용
- static 으로 선언된 변수나 메서드는 클래스의 '인스턴스에 속하지 않음.'
  (해당 클래스의 인스턴스가 전부 동일한 값을 공유함을 의미)
- 클래스 자체에 속하게 됨.
- 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 필드, 메서드와 구분 됨.

## 특징
1. 공유 : 모든 인스턴스가 동일한 static 변수에 접근합니다. 따라서 데이터를 공유하거나 상태를 저장할 때 유용.
2. 클래스 수준의 변수 및 메서드 : static 변수와 메서드는 클래스 로드 시 메모리에 할당
   (객체가 생성될 때가 아니라).
```java
@AllArgsConstructor
public class KoreaITStudent07 extends KoreaITStudent {
    // 클래스 변수 선언
    private staticString introduction = "코리아 아이티 국비 과정 7월";
    //field
    private String name;
    private int age;
    private String address;
//    private String introduction = "코리아 아이티 국비 과정 7월";
}

public class Main {
    public static void main(String[] args) {
        KoreaITStudent07 student01 = new KoreaITStudent07("김일", 20, "부산광역시");
    } 
}
```
이상의 KoreaITStudent07 클래스의 인스턴스들은 전부 다 private static String '정적 변수'를 가지게 됩니다. 즉, 어느 클래스의 인스턴스인지만 확인하더라고 몇 월 국비생인지 확인할 수 있습니다.(예를 들어 KoreaItStudent04)의 객체는 코리아 아이티 국비 과정 4월이라는 private static String 정적 변수를 가짐, 일일이 객체의 필드에 정의할 필요도 없음)

3. 인스턴스가 필요 없음 : 객체를 생성하지 않고도 클래스명.필드 / 클래스명.메서드명() 형태로 직접 접근 가능(필드는 private 접근 지정자가 아니어야함).
4. 메모리 효율성 : static 변수는 프로그램이 종료될 때까지 한 번만 메모리에 할당됨.

# Singleton Pattern (싱글톤 패턴)
## 정의
소프트웨어 '디자인 패턴' 중 하나로, 어떤 클래스가 '하나의 인스턴스만 갖도록 보장하고,' 그 인스턴스에 접근할 수 있는 '전역적인 접근법'을 제공하는 패턴. 예를 들어, 데이터베이스 연결과 같은 리소스는 프로그램 전체에서 하나의 인스턴스만 사용해야 할 때가 많기 때문에 싱글톤 패턴을 사용함.

## 특징
1. 하나의 인스턴스만 존재 : 하나의 인스턴스만 생성되고, 이 인스턴스는 프로그램이 실행되는 동안 유지
2. 전역 접근법 : 싱글톤 인스턴스는 정적(static) 메서드를 통하여 어디서든 접근 가능
    -> 객체명.메서드명() x / 클래스명.메서드명();
3. 인스턴스의 생명 주기 관리 : 클래스 자체가 인스턴스 생성을 관리하므로, 다른 객체들이 인스턴스를 생성하거나 폐기할 수 없음.

### 장점
1. 메모리 절약 : 불필요한 인스턴스 생성을 방지하여 메모리 절약 가능(static 변수 / 메서드의 장점과 같음.)
2. 글로벌(전역적) 접근 : 전역적 접근이 가능하여 메모리 관리가 용이 -> 다만 잦은 접근 자체는 단점
3. 일관성 유지 : 애플리케이션 전반에서 하나의 인스턴스만 사용하기 때문에 상태 일관성을 유지

### 단점
1. 테스트 어려움 : 싱글톤 패턴은 전역적으로 사용되므로 '단위 테스트'가 어려울 수 있음. (대부분 메서드 단위)
2. 의존성 숨김 : 싱글톤을 남용하면 클래스 간의 의존성을 추적하기 어려울 수 있음.

# 빌더 패턴(Builder Pattern) 
```java
@AllArgsConstructor
public class Student {
    private int code;
    private String name;
    private String gender;
    private String school;
    private int semester;
    private String[] subjects;
    private double[] scores;
}

public class StudentMain {
    Student student1 = new Student(여기 내부에 이상의 필드가 다 입력되어야함, 
            순서대로);
}
```
# 빌더 패턴이 생기게 된 원인
1. 복잡한 생성자 문제
    - 객체의 필드가 많아질 수록 생성자 파라미터 수도 늘어남.
      - 위의 예시에서 AllArgs만 정의했지만 매개변수 생성자를 종류별로 써야함.
      - 롬복을 도입했다고 하더라고 필수적인 것은 final 이나 @Nonnull을 추가로 지정해줘야함.
2. 생성자 오버로딩 문제
    - 생성자에 필요한 조합이 다를 경우 수 많은 생성자들을 일일이 정의해야함.
    - 유지 보수에 악영향 / 필드 하나 추가하면 생성자를 다 뜯어고쳐야 함.
      - RemoteController 작성할 때, VolumeDownButton을 추가하니까 main 단계에
        있는 생성자에 필드를 추가해줘야하고, 생성자를 지웠다가 alt + ins 해서 다시
        만들어주고 하는 귀찮은 과정들이 있음.
3. 가독성과 유지 보수 문제
   - 코드를 작성하고 읽는 입장에서는 객체를 생성할 때 어떤 값이 어떤 필드에 해당하는지
     명확하지 않아서 실수를 유발할 수 있음.
```java
public static void main(String[] args) {
    Student student1 = new Student("김일", "김이");
    //라고 했을 때 김일초등학교의 김이 학생인지 김일 학생이 김이초등학교인지 알게 뭐냐는 문제
}
```

## 정의
객체의 생성 과정에서 '복잡한 생성자'를 대신하여 객체를 '단계적으로' 생성할 수 있도록
도와주는 디자인 패턴 중 생성 관련 파트. GoF(Gang of Four) 디자인 패턴 중 하나로
객체 생성 시 가독성과 유연성을 제공하는 것이 목표.
    - 여기서 유연성의 의미는 필드를 순서대로 채워넣지 않고 순서를 바꾸더라도 
    제대로 알아서 필드에 들어간다는 것을 의미
```java
public class Student {
    private String name;
    private String school;
    
    public Student(String name, string school) {
        this.name = name;
        this.school = school;
    }

    public Student(String school, string name) {
        this.name = name;
        this.school = school;
    }
}
```
## 특징
1. 객체를 생성하는 여러 개의 필드를 '명시적'으로 관리할 수 있음.
2. 불필요한 생성자 오버로딩(위의 예시)을 줄여 가독성을 높임.
3. 체이닝 메서드를 사용하여 객체를 직관적으로 생성
    - chaining method - 객체명.getClass().getSimpleName();이 예시