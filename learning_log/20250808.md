# 참조 자료형 캐스팅(Reference Type Casting)
- 객체 지향 프로그래밍에서 중요한 오소 중 하나
# 사전 지식
- 자바 상에서의 자료형은 크게 두 가지로 구분됨.
1. 기본 자료형(Primitive Type) : int, double, char, float, long
2. 참조 자료형(Reference Type) : 객체를 참조하는 변수로, 클래스나 인터페이스로 생성된 객체
- 참조 자료형 캐스팅이란? 객체의 자료형을 변환하는 작업.
- int -> double / int -> long으로 변경하는 것 = 형변환(conversion)

## 캐스팅 종류
1. 업캐스팅 : 하위 클래스 타입의 객체를 상위 클래스 타입으로 변환
2. 다운캐스팅 : 상위 클래스 타입의 객체를 하위 클래스 타입으로 변환

## 미리 기억해야 할 연산자(operator) : instanceof
ex) 1 + 1 = 2 에서 + 는 연산자 / = 대입 연산자인 것처럼,
ex) 객체명 instanceof 클래스명 -> return true / false

### Upcasting
- 암시적(Implicit)으로 이루어짐
  - 알아서 바뀐다. 근데 언제 알아서 바뀌었는지는 개발자가 알고 있어야 함.
### Downcasting
- 명시적(explicit)으로 이루어짐
  - 반드시 개발자가 적절한 장소와 시간대에 사용해야 한다.
## 업캐스팅가 다운캐스팅의 활용
- 캐스팅은 다형성(Polymorphism)을 구현할 때 사용. 상위 클래스 타입으로 객체를 
    처리하면서도 특정 상황에서는 하위 클래스의 고유 기능을 사용 가능
## 장단점
- 장점 :
  - 코드 유연성 : 업캐스팅을 통해 '다양한 객체를 상위 클래스 타입으로 관리' 가능
  - 다형성 구현 : 메서드 오버라딩과 함께 사용하면 코드의 재사용성이 올라감
- 단점 :
  - 다운캐스팅의 위험성 : 잘못 다운캐스팅을 하게 될 수 있음.
    - 상위 클래스 A와 하위 클래스 B, C가 있다고 가정할 때, B의 객체인 b를 A로 업캐스팅한 후에 C로 다운캐스팅을 하려고 시도하면 컴파일링 오류 발생.
  - 복잡성 증가 : 코드 가독성이 떨어질 수 있음.
    - 이렇게 바꿨다가 저렇게 바꿨다가 하기 때문인데 특히 업캐스팅의 경우 암시적으로 일어나기 때문에 어디서 이루어졌는지 확인 못하고 있다가 갑자기 명시적으로 작성하는 다운캐스팅이 튀어나와서 초심자들이 코드 읽는게 어려워지는 경우가 발생할 수 있음.
    - 이상의 문제들을 해결하기 위한 연산자가 ->instanceof
  코드 예시
```java
public static void main(String[] args) {
    System.out.println(objectA instanceof ClassA); //결과값 true / false
} 
//ObjectA 검사하려는 객체명
//ClassA 객체가 검사될 클래스 / 인터페이스
```
- return value는 objectA가 ClassA의 인스턴스이거나 '하위' 클래스의 인스턴스인 경우 true 아니면 false

++ 참조 자료형 재정리 ++
참조 자료형 캐스팅 ? "같은 계열(상속/구현 관계)에 있는 객체"를 다른 타입으로 바꾸는 것

업캐스팅 - 자동 형변환
why? 
- 자식 클래스 -> 부모 클래스 변환
```java
class Animal {}
class Dog extends Animal {}

Animal animal = new Dog(); //클래스명A a = new 클래스명B; 
```
다운캐스팅 - 강제 형변환
why? 자식 클래스의 고유 메서드를 사용하기 위해서
- 부모 -> 자식 클래스 변환
```java
Dog dog = (Dog) animal; //(클래스명) 객체명
```
//다운캐스팅 시에 에러를 막기 위해 형변환 전에 자식타입을 확인하려고
instanceof 기본구조
if (참조변수 instanceof 타입) {
  //참조변수가 해당 타입이 맞을 때(true) 실행
}

Total Example

```java
class Animal {
    void sound() {
        System.out.println("Animal sound");
    }
}

class Dog extends Animal {
    void bark() {
      System.out.println("Woof");
    }
}

public class Main {
  public static void main(String[] args) {
    Animal animal = new Dog(); // 업캐스팅
    
    // 다운캐스팅 전 확인
    if (animal instanceof Dog) {
        Dog dog = (Dog) animal;
        dog.bark(); // 자식 클래스의 메서드 사용 가능
    }
  }
}
```